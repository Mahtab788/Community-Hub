<h1>Geometries</h1>
<p>We will use Different inbuild Geometries in THREE.js</p>
<br>
<p>First do the BASIC STEPS of creating Scene, Camera, Renderer and Recurring function.</p>
<br>
So before Defining Recursive function, we will create lights, materials, geometries and meshes.
<br>
<p>We create Two lights</p>
<p>1. Ambient Light</p>
<p>2. Point Light</p>
<p>Ambient Light is a constant Light on all sides, its like a base light</p>
<pre>
var ambientLight = new THREE.AmbientLight(0xffffff,0.5);
scene.add(ambientLight);
</pre>
<br>
<p>First Parameter requires a color value</p>
<p>Second parameter is for Intensity, it goes from 0 to 1</p>
<p>Since Ambient Light is same at all corners, position is not required</p>
<br>
<p>Point light is like a point source of light</p>
<pre>
var pointLight = new THREE.PointLight(0xffffff,1,1);
pointLight.position.set(2,1,2);
scene.add(pointLight);
</pre>
<br>
<p>First and Second parameters are for Color and Intensity respectively</p>
<p>Third Parameter is for decay, The amount the light dims along the distance of the light. Default is 1</p>
<p>Since it is a point, it requires a position in 3D space</p>
<br>
<p>After Lights, create a Material. We will use the same material for all geometries</p>
<pre>
var material = new THREE.MeshStandardMaterial({color:0xff6666});
</pre>
<br>
<p>Now create different Geometries for different Objects</p>
<pre>
var geom1 = new THREE.BoxBufferGeometry(1,1,1);
var geom2 = new THREE.SphereBufferGeometry(0.7,32,32);
var geom3 = new THREE.TorusBufferGeometry(0.7,0.4,64,64);
var geom4 = new THREE.ConeBufferGeometry(0.7,0.7,64);
</pre>
<br>
<p>Here 'geom1' is Box geometry, it requires (length, width, height)</p>
<p>which means Distance along (X, Y, Z) axes.</p>
<br>
<p>'geom2' is Sphere geometry, it requires (Radius, Horizontal lines, Vertical lines)</p>
<p>Horizontal and Vertical lines for smoothness, if its value is low then Sphere will have edges</p>
<br>
<p>'geom3' is Torus/Donut geometry, it requies (Total Radius, width of Torus, Horizontal lines, Vertical lines</p>
<br>
<p>'geom4' is cone geometry, it requires (Height, Width, Vertical lines</p>
<br>
<br>
<p>After creating different geometries, lets create meshes and use the geomety and material</p>
<pre>
var cube = new THREE.Mesh(geom1,material);
scene.add(cube);
    
var sphere = new THREE.Mesh(geom2,material);
sphere.position.x = -2;
scene.add(sphere);
    
var torus = new THREE.Mesh(geom3,material);
torus.position.x = 2;
scene.add(torus);
    
var cone = new THREE.Mesh(geom4,material);
cone.position.y = -1.3;
scene.add(cone);
</pre>
<br>
<p>We created a Mesh named cube and inside it, we passed geom1 (BoxGeometry) and material</p>
<p>AT last positioned meshes accordingly</p>
<br>
<br>
<pre>
var floor = new THREE.Mesh(
new THREE.PlaneBufferGeometry(4,4),
new THREE.MeshStandardMaterial({color:0x333333})
);
floor.position.y = -1.65;
floor.rotation.x = -Math.PI/2
scene.add(floor);
</pre>
<p>At last we create a floor by using 'PlaneBufferGeometry' and created a material of different color</p>
<br>
<p>After creating any mesh, one should not forget to add it, in the Scene</p>
<br>
<p>So here we greated some basic geometries and Rendered it in the browser window</p>
<br>
<br>
<p>Apart from These geometries we have:-</p>
<li>CircleGeometry</li>
<pre>
var circleGeom = new THREE.CircleGeometry(1,32,0,Math.PI*2);
// it requires (radius, segments, angleRotated, angelLength);
// angelLength and angleRotated goes from 0 to Math.PI*2;
</pre>
<br>
<li>CylinderGeometry</li>
<pre>
var cylinderGeom = new THREE.CyliderGeometry(2,2,20,32,2,true,0,Math.PI*2);
// it requires (radiusTop, radiusBottom, Height, Vertical segment, Horizontal lines, openEnded, angleRotated, angelLength);
// openEnded is a boolean dataType;
// angelLength and angleRotated goes from 0 to Math.PI*2;
</pre>
<br>
<li>DodecahedronGeometry</li>
<pre>
var dodecGeom = new THREE.DodecahedronGeometry(2,0);
// it requires (radius, details);
//if details value is increased, it add more vertices
</pre>
<br>
<li>IcosahedronGeometry</li>
<pre>
var icosaGeom = new THREE.IcosahedronGeometry(2,0);
// it requires (radius, details);
//if details value is increased, it add more vertices
</pre>
<br>
<li>OctahedronGeometry</li>
<pre>
var octaGeom = new THREE.OctahedronGeometry(2,0);
// it requires (radius, details);
//if details value is increased, it add more vertices
</pre>
<br>
<li>TetrahedronGeometry</li>
<pre>
var tetraGeom = new THREE.TetrahedronGeometry(2,0);
// it requires (radius, details);
//if details value is increased, it add more vertices
</pre>
<br>
<li>RingGeometry</li>
<pre>
var ringGeom = new THREE.RingGeometry(0.3,1.3,32,4,0,Math.PI*2);
// it requires (innerRadius, outerRadius, angleSegment, phiSegment, angleRotated, angelLength);
// angelLength and angleRotated goes from 0 to Math.PI*2;
</pre>
<br>
<li>TorusKnotGeometry</li>
<pre>
var torusKnotGeom = new THREE.TorusKnotGeometry(2,0.7,64,64,2,3);
// it requires (radius, width, Horizontal seg, Vertical seg, p, q);
// p determines, number of times the geometry winds around its axis of rotational symmetry. Default is 2.
// q determines, number of times the geometry winds around a circle in the interior of the torus. Default is 3.
</pre>
<br>
<li>ExtrudeGeometry</li>
<pre>
var extrudeGeom = new THREE.ExtrudeGeometry(2,16,1,1,0,1);
// it requires (Vertical Seg, Width, bevelThickness, bevelSize, bevelOffset, bevelSegment);
</pre>
<br>
<p>You can try these Geometries, according to your needs</p>
<br>
<br>
<br>